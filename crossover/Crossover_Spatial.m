% Matt Ryerkerk - Michigan State University - June 2019
% 
% Perform a spatial crossover using the variables that have been marked as
% spatial variables in params. This generates a randomly positioned and oriented
% hyperplane to split the design space in two, assigning either part from each 
% parent to each child.
%
% Note that this operates slightly differently than how its described in the dissertation. 
% Here we operate in the non-normalized metameric space.
%
% inputs: (blank indicates the parameter is not used by this function)
%   params.varList: Vector of Variables used in this problem
%   params.spatialVariables: A list of the indicies of variables that are
%     to be used in the spatial crossover. For example, if this equaled [2,
%     3] then the second and third variables in params.varList will be used
%     to partition the solutions.
%   parent1, parent2: The two parent solutions. 
%
% Outputs:
%   params, outputs: Unchanged by this function
%   child1, child2: The unevaluated children generated by this function.

function [params, outputs, child1, child2] = Crossover_Spatial(params, outputs, parent1, parent2)

vars = params.varList; % List of variables.
spatialIndex = params.spatialVariables; % Indices of variables used for spatial crossover  

% If this is an ordered problem then add index values to parent genotypes.
% The genome will be partitioned based on these values, regardles of what has been
% set in params.spatialVariables
if (params.orderedProblem == 1) 
  parent1.genome(:,end+1) = linspace(0,1,size(parent1.genome, 1)); % Add an index variable to end of parent genomes
  parent2.genome(:,end+1) = linspace(0,1,size(parent2.genome, 1));
  vars(end+1) = Variable; 
  vars(end).lower = 0; 
  vars(end).upper = 1; 
  spatialIndex = length(vars); % Only perform spatial on the index variable
end

DIM = length(spatialIndex); % Number of spatial variables used.
% First, pick a random point inside design space for each spatial variable
x0 = zeros(1,DIM);
for i = 1:DIM
  x0(i) = rand*(vars(spatialIndex(i)).upper - vars(spatialIndex(i)).lower) + vars(spatialIndex(i)).lower;  
end

% Then pick a random normal orientation of the partitioning plane.
% Note the use of randn, not rand here.
n = randn(1, DIM); 

% The plane can be written as:
% n(1)*(x(1)-x0(1)) + n(2)*(x(2)-x0(2)) + .... n(DIM)*(x(DIM)-x0(DIM)) = 0;
%
% We can determine which side of the partitioning plane each metavariable
% lies on by plugging in the design variables for that metavariables into
% the left hand side of the above equation. All metavariables with a
% positive result will belong on one side of the partitioning plane, while
% all metavariables with a negative value will belong on the other side.
val1 = sum(repmat(n, size(parent1.genome, 1), 1).*(parent1.genome(:,spatialIndex) - repmat(x0, size(parent1.genome, 1), 1)), 2);
val2 = sum(repmat(n, size(parent2.genome, 1), 1).*(parent2.genome(:,spatialIndex) - repmat(x0, size(parent2.genome, 1), 1)), 2);

% Form children by exchanging metavariables on either side of line/plane in
% parents
c1 = [parent1.genome(val1 <= 0, :); parent2.genome(val2 > 0, :)]; 
c2 = [parent1.genome(val1 > 0, :); parent2.genome(val2 <= 0, :)]; 

if (params.orderedProblem == 1) % If this is an ordered problem lets sort and remove the order index
  c1 = sortrows(c1, spatialIndex); % Sort by order index, equal to spatial index set earlier
  c2 = sortrows(c2, spatialIndex); 
  c1(:,end) = [];  % Remove sorting index from children
  c2(:,end) = []; 
  parent1.genome(:,end) = []; % Also remove from parents for the following comparisons
  parent2.genome(:,end) = [];  
end

% Create child individuals and compare to parents
[params, outputs, child1, child2] = SetChildrenCrossover(params, outputs, c1, c2, parent1, parent2);